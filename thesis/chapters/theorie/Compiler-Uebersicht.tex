\part{Compiler Theorie}
\chapter{Compiler Uebersicht}
\label{chap:theory:compilerHistory}

\section{Todo Liste}

\begin{itemize}
  \item Was ist ein Compiler?
  \item Compiler Historie
  \item Einleitung zu den detaillierteren Beschreibungen:
  \begin{itemize}
    \item [x] Arten von Compilern 
    \begin{itemize}
    \item[->] Spaeter genauer erklaert: Top-Down Compiler
    \end{itemize}
    \item Compilerphasen
    \begin{itemize}
      \item Einpass vs Mehrpass vs Zweipass zur Trennung Frontend <-> Backend
      \item[->] Spaeter genauer erklaert: Zweipass Compiler fuer separate Backends \& zukuenftige Optimierungsschritte
    \end{itemize}
    \item Parser: Arten (EBNF etc)
    \begin{itemize}
    \item[->] Spaeter genauer erklaert: EBNF
    \end{itemize}
    \item Zwischensprache: Vereinfacht Optimierungen, separierte Backends und Frontends
    \begin{itemize}
      \item[->] Spaeter genauer erklaert: ??? (Wie so ein Zwischenstate aussehen soll ist scheinbar schwarze Magie, selber rausfinden)
    \end{itemize}
    \item Backends: Code Erzeugung etc
    \begin{itemize}
      \item[->] Spaeter genauer erklaert: RISC Binary, RISC assembly
    \end{itemize}
    \item Bootstrapping compiler in eigener Sprache
    \begin{itemize}
      \item[->] Passiert hier nicht, zu komplex und wild
    \end{itemize}
    \item Referenz auf SLICC, meinen Kompiler
  \end{itemize}
\end{itemize}


\section{Compilerhistorie}

Die ersten Computer wurden direkt in Maschinensprache programmiert.
Mithilfe von handgeschriebenen Notationen und Tabellen haben die Programmierer die Übersicht über
die Programme behalten.\\
Mit der Zeit wurden die Aufgaben, die die Maschinen Computer erledigen sollten, immer komplexer und größer.
Über die binären Instruktionen den Überblick zu behalten, wurde damit auch schwieriger.
Statt direkt in Binärcode zu arbeiten, war es leichter, die Operationen in Symbole wie ``LOAD'' und ``ADD'' zu schreiben und zu lesen.
Diese Symbole wurden dann in einem Zwischenschritt durch einen symbolbasierten Assembler in die computer-verständliche Maschinensprache übersetzt.\\
Zusätzlich dazu veränderte sich die Technik; 
Mit der Einführung der Magnettrommelspeicher zum Beispiel kamen Herausforderungen in der Optimierung des Speicherzugriffs auf.
Je nach Ort der Daten konnte die Dauer, auf die Daten mit Direktzugriff zuzugreifen, um einen Faktor von 50 variieren \cite{calingaert:1979}.
Mithilfe eines optimierenden Assemblers wurden die Adresszuweisungen der Daten optimiert, sodass die Zugriffsdauer auf diese Daten verringert wurde.\\
Die Instruktionstypen, die eine damalige Prozessorarchitektur der Computer lesen und bearbeiten konnte, waren sehr limitiert.
Oftmals waren mehrere kleine Instruktionen nötig, um Schritte im Programm darzustellen, die mit einem größeren, expliziteren Instruktionstypen
zusammengefasst werden könnten.
Diese fehlenden Instruktionstypen wurden anfangs mit einem Interpreter hinzugefügt; Ein Programm, das die Übersetzung der programmierten, komplexeren Befehle
in für die Prozessorarchitektur lesbare Befehle übernahm.
Da ein Interpreter selbst auf dem Computer ausgeführt werden muss, führt dies zu deutlichem Mehraufwand in der Ausführung der Programme.
Die ersten Compiler wurden geschrieben, um dieses Problem zu lösen.
Sie übersetzten die vom Programmierer geschriebenen Befehlslisten in für die Prozessorarchitektur des Computers verständliche Instruktionen.
Die Compiler übernahmen mit der Zeit weitere Aufgaben wie Speicherzugriffsoptimierungen und dynamische Speicherallokation.
Verschiedene Programmiersprachen abstrahieren die Prozessorarchitektur weiter.
Sie vereinfachten die Implementierung von Programmen in domänenspezifischen Problemen wie Handel und Forschung und verbreiteten sich später mit dem Aufkommen von Allzweck-Programmiersprachen auch darüber hinaus\cite{calingaert:1979}.

\section{Aufbau eines Compilers}

Heutzutage gibt es eine große Bandbreite an Programmen, die Compiler genannt werden.
Der Compiler im klassischen Sinne übersetzt in Programmiersprachen geschriebenen Programmcode in Maschinencode.
Die ``Cross-Compiler'' hingegen übersetzen von einer Programmiersprache in eine andere Programmiersprache.
Zusätzlich dazu gibt es Compiler (oder auch ``compiler-ähnliche Werkzeuge'') die auf ganz anderen Datenstrukturen arbeiten und zum Beispiel Logdateien in Tabellen kompilieren.
Im Rahmen dieser Arbeit wird der klassische Compiler behandelt, mit dem eine Programmiersprache zu einer Maschinensprache kompiliert wird.\\
Generell gibt es zwei Möglichkeiten, wie diese Compiler aufgebaut werden.
In dem Einpass-Compiler wird der Programmcode in Teilen (Tokens) eingelesen, welche sofort ausgewertet werden.
Ein Token wird eingelesen, geparst und der entsprechende Maschinencode wird generiert.
Dann fährt der Einpass-Compiler mit den nächsten Tokens fort, bis das Ende des Programmcodes erreicht ist.\\
Der Mehrpass-Compiler hingegen liest anfangs den gesamten Programmcode ein und parst ihn mithilfe von mehreren Programmteilen, wo der letzte den Maschinencode ausgibt\cite{mossenbock:2024}.\\
Diese Compiler haben generell 6 Phasen, in denen sie arbeiten:\\
Die Lexikalische Analyse unterteilt das Programm in Tokens, die Einheiten wie Variablennamen oder Operationszeichen aufteilen.\\
Diese Tokens werden dann an die Syntaxanalyse geschickt, wo mithilfe grammatikalischer Regeln die Struktur des Programmcodes überprüft wird.
Die Definition dieser Regeln zusammen mit dem Interpretieren der Tokens wird Parser genannt.
Der Parser ordnet die einzelnen Tokens mitsamt der Regeln in eine Baumstruktur ein.
Es gibt zwei grundlegende Arten von Parsern im Compilerbau;
Der Top-Down Parser baut den Syntax Baum aus der Wurzel heraus und bricht dann die Tokens immer mehr im Detail runter, während der Bottom-Up Parser mit den einzelnen Tokens anfängt und diese zusammenfasst um einen Syntax Baum zu generieren\cite{meduna2007elements}.

\textbf{\textit{Bild Top Down vs Bottom Up Tree}}

Nach dem Parsen wird eine semantische Analyse auf dem Syntaxbaum ausgeführt, wo zum Beispiel die Typen von Variablen überprüft werden.
Wird einer Variable von Typ ``int'' inkorrekterweise ein Wert vom Type ``string'' zugewiesen wird das in der semantischen Analyse als Fehler aufgezeigt.
Nach diesen Schritten 
